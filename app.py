# -*- coding: utf-8 -*-
"""app

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ERKrZrEZwNGUfl04C0BRvmhcyHzsHo9s

https://www.google.com/search?q=d%C3%A9ployer+un+mod%C3%A8le+Machine+Learning+dans+une+application+web+python&rlz=1C1GCEA_enFR1040FR1040&sxsrf=AJOqlzUoKc2uoDsDPeJ6oE8fX-ylcHoxAA:1676554155784&source=lnms&tbm=vid&sa=X&ved=2ahUKEwjmwZv3kpr9AhWXY6QEHYnACsMQ_AUoAXoECAIQAw&biw=1280&bih=569&dpr=1.5#fpstate=ive&vld=cid:b07ffca4,vid:u0Syto1oAGA
"""

# Installation de streamlit
# Enlever lors de l'exécution de l'application

# !pip install streamlit

# Librairies nécessaires
# Les librairies dont l'installation est requise sont mentionnées dans le fichier "requirement.txt" dans le github

import streamlit as st
import pandas as pd
import numpy as np
from sklearn.ensemble import GradientBoostingRegressor

# Design de l'application

# Ajouter une vidéo en bannière
# st.video("")

# Description

st.title("BringItHome")

st.write('''
# Une maison, un prix.
Bienvenue chez BringItHome, l'agence immobilière innovante qui vous aide à estimer la valeur de votre propriété en toute simplicité.

Notre outil de prédiction de prix utilise les dernières technologies d'apprentissage automatique pour fournir des estimations précises et fiables, en se basant sur des données de marché de ??. Il vous suffit de renseigner les caractéristiques de votre propriété, telles que la taille, l'emplacement et les équipements, pour obtenir une estimation immédiate.
Chez Propertize, nous comprenons que la vente ou l'achat d'une propriété est une décision importante, c'est pourquoi nous sommes déterminés à vous fournir les informations les plus précises possibles pour vous aider à prendre une décision éclairée.

Alors, pourquoi attendre ? Utilisez dès maintenant notre outil de prédiction de prix pour estimer la valeur de votre propriété.

BringItHome - Les clés qui vous donnent le pouvoir.
''')

# L'utilisateur répond à des questions et entre les paramètres correspondant à son souait, selon des variables regroupées 
# selon un "thème", comme l'aspect général de la maison, ses extérieurs, ou sa modernité.

def user_input():

  ############### ASPECT GENERAL
  st.sidebar.header("Si l'on commençait par son aspect général ?")
  
  #### LotArea : taille de la surface 
  # Demander à l'utilisateur de saisir la valeur de la surface
  min_value_LotArea = 10
  max_value_LotArea = 3000
  LotArea = st.sidebar.text_input("Taille de la maison avec son extérieur (en mètres carrés)", value = 100)
  
  # Vérifier que la saisie est valide
  try:
    selected_value = int(LotArea)
    if selected_value < min_value_LotArea or selected_value > max_value_LotArea:
      raise ValueError
  except ValueError:
      st.sidebar.warning(f'Veuillez saisir une surface comprise entre {min_value_LotArea} et {max_value_LotArea}.')
  else:
      LotArea
  
  # Vérifier le type rentré
  if not LotArea.isnumeric() and not LotArea.replace('.', '', 1).isnumeric():
      st.sidebar.error('La surface en mètres carrés doit être inscrite en nombre entier.')
  else:
        # Convertir la saisie en float
        LotArea_float = float(LotArea)

  #### GrLivArea : surface habitable au-dessus du sol (en mètres carrés)
  # Demander à l'utilisateur de saisir la valeur de la surface
  min_value_GrLivArea = 10
  max_value_GrLivArea = 3000
  GrLivArea = st.sidebar.text_input("Surface habitable au-dessus du sol (en mètres carrés)", value = 100)
  
  # Vérifier que la saisie est valide
  try:
    selected_value = int(GrLivArea)
    if selected_value < min_value_GrLivArea or selected_value > max_value_GrLivArea:
      raise ValueError
  except ValueError:
      st.sidebar.warning(f'Veuillez saisir une surface comprise entre {min_value_GrLivArea} et {max_value_GrLivArea}.')
  else:
      GrLivArea
  
  # Vérifier le type rentré
  if not GrLivArea.isnumeric() and not GrLivArea.replace('.', '', 1).isnumeric():
      st.sidebar.error('La surface en mètres carrés doit être inscrite en nombre décimal.')
  else:
        # Convertir la saisie en float
        GrLivArea_float = float(GrLivArea)

  #### MS_zoning_RL : densité de l'endroit résidentiel
  labels_MS_zoning_RL = [0,1]
  options_MS_zoning_RL = {
      1 :'Forte densité résidentielle',
      0 : 'Faible densité résidentielle'
      }
  MS_zoning_RL = st.sidebar.radio("Densité du quartier", labels_MS_zoning_RL, format_func=lambda x: options_MS_zoning_RL[x])
  

  ############### INTERIEUR
  st.sidebar.header("Passons à l'intérieur. Après vous.")

  #### KitchenQual : nombre de pièces
  TotRmsAbvGrd = st.sidebar.number_input("Nombre de pièce(s)", value = 1, step = 1, min_value=1, max_value=None)

  #### FullBath : nombre de salle(s) de bain
  FullBath = st.sidebar.number_input("Nombre de salle(s) de bain", value = 1, step = 1, min_value=1, max_value=None)
  
  #### HalfBath : nombre de toilette(s) séparées
  HalfBath = st.sidebar.number_input("Nombre de toilette(s) séparées", value = 1, step = 1, min_value=1, max_value=None)

  ############### EQUIPEMENTS
  st.sidebar.header("Des remarques sur les équipements ?")

  #### OverQual : qualité générale
  OverallQual=st.sidebar.slider("Qualité du matériau global et de la finition sur 10", 0,10, value = 5)

  #### KitchenQual : qualité de la cuisine
  KitchenQual=st.sidebar.slider("Qualité de la cuisine sur 10", 0,10, value = 5)

  #### HeatingQC : qualité du chauffage
  labels_HeatingQC= [1, 2, 3, 4, 5]
  defaultHeat=3
  options_HeatingQC = {
              1 :'Excellent',
              2 : 'Bon',
              3 : 'Moyen',
              4 : 'Faible',
              5 : 'Pauvre'
          }
  HeatingQC = st.sidebar.radio("Qualité et condition du chauffage et de la consommation énergétique", labels_HeatingQC, 
                               format_func=lambda x: options_HeatingQC[x], index=labels_HeatingQC.index(defaultHeat))

  #### Fireplaces : nombre de cheminée(s)
  # On utilise st.checkbox() pour afficher une case à cocher
  Fireplaces_want_option = st.sidebar.checkbox("Vous chauffez-vous aussi avec une cheminée ?")

  # Si la case est cochée, on affiche un curseur st.slider()
  if Fireplaces_want_option:
    Fireplaces=st.sidebar.number_input("Précisez-nous combien de cheminée(s)", step=1, value=0, min_value=0, max_value=None)
  else:
      Fireplaces = 0 

  #### TotalBsmtSF : taille de la surface du sous-sol 
  # On utilise st.checkbox() pour afficher une case à cocher
  TotalBsmtSF_want_option = st.sidebar.checkbox("Un sous-sol est une surface supplémentaire. Qu'en dites-vous ?")

  # Si la case est cochée, on affiche un curseur st.slider()
  if TotalBsmtSF_want_option:

    # Demander à l'utilisateur de saisir la valeur de la surface
    min_value_TotalBsmtSF = 5
    max_value_TotalBsmtSF = 600
    TotalBsmtSF = st.sidebar.text_input("Quelle est sa taille (en mètres carrés) ?", value = 20, min_value=0, max_value=None)
    
    # Vérifier que la saisie est valide
    try:
      selected_value = int(TotalBsmtSF)
      if selected_value <= min_value_TotalBsmtSF or selected_value > max_value_TotalBsmtSF:
        raise ValueError
    except ValueError:
        st.sidebar.warning(f'Veuillez saisir un nombre entier entre {min_value_TotalBsmtSF} et {max_value_TotalBsmtSF}.')
    else:
        TotalBsmtSF
    
    # Vérifier le type rentré
    if not TotalBsmtSF.isnumeric() and not TotalBsmtSF.replace('.', '', 1).isnumeric():
        st.sidebar.error('La surface en mètres carrés doit être inscrite en nombre décimal.')
    else:
          # Convertir la saisie en float
          TotalBsmtSF_float = float(TotalBsmtSF)

    #### BsmtQual : qualité du sous-sol
    BsmtQual=st.sidebar.slider("La qualité de cet espace sur 10", 0, 10, value = 5)  

  else:
      TotalBsmtSF = 0 
      BsmtQual = 0

  #### GarageCars : capacité du garage en nombre de voiture
  # On utilise st.checkbox() pour afficher une case à cocher
  Garage_want_option = st.sidebar.checkbox("Un garage pour une voiture ou du bricolage ?")

  # Si la case est cochée, on affiche un curseur st.slider()
  if Garage_want_option:
      GarageCars = st.sidebar.number_input("Pour combien de voitures à mettre à l'abri ?", value = 1, step = 1, min_value=0, max_value=None)
      GarageCond = st.sidebar.slider("Et vous jugeriez la qualité du garage sur 10", 0,10, value = 5)
  else:
      GarageCars = 0
      GarageCond = 0


  ############### EXTERIEUR
  st.sidebar.header("Terminons par un tour de l'extérieur.")

  #### ExterQual : qualité extérieure
  ExterQual=st.sidebar.slider("Qualité du matériau extérieur sur 10", 0, 10, value = 5)

  #### ModernityInYears : dernière rénovation
  ModernityInYears=st.sidebar.slider("Nombre d'années avant la dernière rénovation", 0,60, value = 10)

  #### WoodDeckSF : taille de la terrasse (en mètres carrés)
  # On utilise st.checkbox() pour afficher une case à cocher
  terrasse_want_option = st.sidebar.checkbox("Une terrasse ?")

  # Si la case est cochée, on affiche un curseur st.slider()
  if terrasse_want_option:
      WoodDeckSF = st.sidebar.number_input("Quelle taille donc (en mètres carrés) ?", value = 10, step = 1, min_value=0, max_value=None)
  else:
      WoodDeckSF = 0

  #### OpenPorchSF : taille de la véranda (en mètres carrés)
  # On utilise st.checkbox() pour afficher une case à cocher
  OpenPorchSF_want_option = st.sidebar.checkbox("Et une véranda ?")

  # Si la case est cochée, on affiche un curseur st.slider()
  if OpenPorchSF_want_option:
      OpenPorchSF = st.sidebar.number_input("C'est noté ! Dites-nous sa taille (en mètres carrés)", value = 10, step = 1, min_value=0, max_value=None)
  else:
      OpenPorchSF = 0

  data={'LotArea':LotArea,
        'OverallQual':OverallQual,
        'ExterQual':ExterQual,
        'BsmtQual':BsmtQual,
        'TotalBsmtSF':TotalBsmtSF,
        'HeatingQC':HeatingQC,
        'GrLivArea':GrLivArea,
        'FullBath':FullBath,
        'HalfBath':HalfBath,
        'KitchenQual':KitchenQual,
        'TotRmsAbvGrd':TotRmsAbvGrd,
        'Fireplaces':Fireplaces,
        'GarageCars':GarageCars,
        'GarageCond':GarageCond,
        'WoodDeckSF':WoodDeckSF,
        'OpenPorchSF':OpenPorchSF,
        'MS_zoning_RL':MS_zoning_RL,
        'ModernityInYears':ModernityInYears
        }
  maison_parametre=pd.DataFrame(data,index=[0])
  return maison_parametre
            
df=user_input()

st.write(df)

# Chargement des ensembles de test et d'apprentissage

url_Xtrain = 'https://raw.githubusercontent.com/laurianerobin/DS11/main/X_train.csv'
X_train = pd.read_csv(url_Xtrain,parse_dates=[0])

url_ytrain = 'https://raw.githubusercontent.com/laurianerobin/DS11/main/y_train.csv'
y_train = pd.read_csv(url_ytrain,parse_dates=[0])

url_Xtest = 'https://raw.githubusercontent.com/laurianerobin/DS11/main/X_test.csv'
X_test = pd.read_csv(url_Xtest,parse_dates=[0])

url_ytest = 'https://raw.githubusercontent.com/laurianerobin/DS11/main/y_test.csv'
y_test = pd.read_csv(url_ytest,parse_dates=[0])

# Application du meilleur modèle retenu

model_best = GradientBoostingRegressor(learning_rate = 0.1, max_depth = 3, n_estimators = 100, random_state = 42)
model_best.fit(X_train, y_train)

# Prédiction sur les données sélectionnées

prediction=model_best.predict(df)
pred = np.exp(prediction)

st.subheader("Le prix de la maison est :")

# format du nombre pour le prix
import locale
locale.setlocale(locale.LC_ALL, '')
locale._override_localeconv = {'mon_thousands_sep': ' '}

st.write(pred)

# retranscription du prédix
pred_format = locale.format('%s', round(pred,0), grouping=True, monetary=True)
st.markdown("Son prix est estimé à **:blue[pred_format]**")

st.write('''
Notre outil de prédiction est basée sur un modèle d'apprentissage. 
À titre informatif, ce modèle a été entraîné sur l'analyse de plus d'un millier de maisons résidentielles à Ames dans l'Iowa, données consitutées par l'Association Statistique Américaine (ASA).
''')

score_train = model_best.score(X_train, y_train)
score_test = model_best.score(X_test, y_test)

st.write("Sur ces données, nos équipes de data analysts sont parvenus à prédire correctement", round(score_test*100,2)," % sur des données de tests.")
